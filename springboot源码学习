SpringBoot重要的类和执行顺序：
ApplicationContextInitializer和ApplicationListener实例化
SpringApplicationRunListener实例化和通过EventPublishingRunListener发布整个服务启动过程中的事件
初始化环境变量和JVM变量
创建ApplicationContext并赋值环境变量和执行ApplicationContextInitializer
开始刷新applicationContext
BeanFactoryPostProcessor处理1（除了实例化直接加入的同时也包括BeanDefiniton中的）：BeanDefinitionRegistryPostProcessor向BeanFactory中加入BeanDefinition（包扫描）.其中最重要的ConfigurationClassPostProcessor和MapperScannerConfigurer 一个扫描包一个扫描mapper生成FactoryBean
BeanFactoryPostProcessor处理2（除了实例化直接加入的同时也包括BeanDefiniton中的）：BeanFactoryPostProcessor 主要是处理BeanFactory中已经存在的BeanDefinition或者加入一些单例对象如BeanPostProcessor等
从BeanFactory中解析出BeanPostProcessor对象并保存到BeanFactory中
处理applicationEventMulticaster和applicationListener
初始化tomcat server，和配置其最大连接数，线程数等
开始进行Bean的初始化
构造bean之前会先执行InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation是否直接返回该BeanName对应的对象不进行正常的实例化，属性赋值等，但都会执行BeanPostProcessor.postProcessAfterInitialization
构造bean之前通过SmartInstantiationAwareBeanPostProcessor决定何种方式实例化
Bean的实例化对象后，会调用MergedBeanDefinitionPostProcessor解析需要赋值的注解属性，缓存到相应的BeanPostProcessor中，主要是CommonAnnotationBeanPostProcessor AutowiredAnnotationBeanPostProcessor RequiredAnnotationBeanPostProcessor 
提前暴露实例化的Bean,还没有被属性赋值，保存在earlySingletonObjects用于解决循环依赖
属性赋值前InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation来判断bean是否需要属性填充，如果不需要则直接返回
调用InstantiationAwareBeanPostProcessor.postProcessProperties进行属性的填充，完成自动装配
注入属性赋值后执行Bean的Aware接口BeanNameAware、BeanClassLoaderAware、BeanFactoryAware继续进行属性赋值
初始化1，执行BeanPostProcessor.postProcessBeforeInitialization （@PostConstruct实在此处执行的CommonAnnotationBeanPostProcessor）
初始化2，执行InitializingBean接口和InitMethod
执行BeanPostProcessor.postProcessAfterInitialization
如果是FactoryBean的话，BeanName会加上前缀&BeanName，并且通过getObject返回BeanName的Bean (mybatis的mapper接口注入的是一个代理类，代理最终通过一个事务ThreadLocal的SqlSession来执行)
初始化一个lifecycleProcessor，并调用实现了SmartLifecycle接口bean的start方法
启动tomcat-server
注册shutdownHook其负责调用的销毁工作已经Lifecycle.stop方法和关闭tomcat server
执行ApplicationRunner和CommandLineRunner接口
