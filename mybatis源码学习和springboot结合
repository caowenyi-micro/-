mybatis启动流程：mybatis解析->sqlsession创建-> mapper执行（jdk动态代理委托给sqlsession执行，并找到缓存的SqlCommand语句）
mybatis解析：
解析mybatis-config文件和其中配置的mapper.xml文件生成configuration对象。
在configuration对象中通过map来保存解析出来的xml中元素，可以都是每个xml的namespace+id 如：每个mapper的二级缓存：Map<String, Cache> cache。ResultMap元素Map<String, ResultMap> resultMaps.  Map<String, ParameterMap> parameterMaps。
configuration还包括几个比较最重要的对象：MapperRegistry mapperRegistry（保存接口和代理类的关系），InterceptorChain interceptorChain保存所有的拦截器，Environment environment保存了datasource和事务管理器transactionFactory
mapperRegistry由：Configuration configuration 和 Map<Class<?>, MapperProxyFactory<?>> knownMappers组成，其中knownMappers保存的mapper接口类和代理工厂类之间的关系，最终在通过接口调用的时候，会调用通过工厂类生产的MapperProxy对象来代理执行。

sqlsession创建：
sqlsession是通过DefaultSqlSessionFactory创建的，在创建的时候会从configuration取出事务管理器创建事务，并通过执行器类型创建出executor,最终sqlsession通过new DefaultSqlSession(configuration, executor, autoCommit)创建。（一个sqlSession 一个事务 一个connection 一个executor 一个一级缓存)
executor通过判断是否在mapper中配置了cache, 如果配置了则装饰器模式是创建出一个带有二级缓存的executor。executor = new CachingExecutor(executor); cachingExecutor中的cache来源于MapperStatement及最终从xml配置的cache
最后sqlsession的所有查询操作都是委托给executor来执行的。其中由于cacheExecutor中装饰的cache是都带有一个localCache(在基类BaseExecutor中）因此一级缓存是sqlsession返回有效的（一个sqlsession一个executor）。
sqlsession的拦截器生效是通过代理模式：executor = (Executor) interceptorChain.pluginAll(executor); 对executor进行多次代理产生的，使得每次sqlsession执行的时候都可以嵌套配置的Interceptor.intercept(Invocation invocation)

mapper执行：
sqlsession.getMapper()是通过获取内部成员变量configuration.mapperRegistry获取的代理对象：Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy); 实际的执行逻辑在mapperProxy中。
 MapperProxy<T> mapperProxy = new MapperProxy<>(sqlSession, mapperInterface, methodCache); 这里的MapperProxy是jdk动态代理的InvocationHandler，但是在构建的时候不是传入的mapper接口的实现类，而是传入的sqlsession。所以mapper接口的方法执行最终是委托给sqlsession来执行的，这个非常重要。所以说mapper重来没有实现类。
在mapperProxy中是通过调用mapperMethod.execute(sqlSession)来执行的，其最终会委托给sqlSession，并传入相关的参数。其中最重要的是namespace.method用来找到config中缓存的执行语句
对于如何通过mapper.method找到对应的xml中的sql语句，则是通过从sqlsession中的configuration中缓存的mappedStatements中取得的。mappedStatements中缓存的就是namespace.method和MappedStatement的关系，（其中通过MappedStatement.getBoundSql,就能获取具体需要执行的sql了）
最后会委托给sqlsession执行并传入相关的sql语句和参数。而sqlSession会调用其配置的executor对象进行执行，执行过程中会执行相关的interceptor代理对象方法，以及如果是cacheExecutor则会执行二级缓存的查找，最终如果二级缓存中没有找到则在sqlsession范围的一级缓存中查找，如果最终都没有找到再从数据库中查找。其中二级缓存是jvm级别的，因此在分布式环境中可能出现缓存不一致的问题。而一级缓存是sqlsession级别的，在srping-mybatis中是threadlocal的，因此缓存只会在同一个session中生效。
executor最终是通过其中的transaction.getConnection()获取的，其保证每个sqlsession一个connection.(同一个SqlSession中只有一个SimpleExecutor，SimpleExecutor中有一个Transaction，Transaction有一个connection) (sqlSession是线程不安全的，如果所有的业务都使用一个sqlSession，那Connection也是同一个，一个业务执行完了就将其关闭，那其他的业务还没执行完呢). 最终transaction的连接是通过dataSource.getConnection()[可配置为连接池 PooledDataSource]获取。最终通过具体的StatementHandler来执行。
closeSqlSession(SqlSession session, SqlSessionFactory sessionFactory)： 对于不带spring事务（通过TransactionSynchronizationManager.getResource(sessionFactory)来判断，非mybatis中的事务包装）的会调用sqlSession.close()-》executor.close-》transaction.close();-》DataSourceUtils.releaseConnection(this.connection, this.dataSource);
对于带spring事务的关闭则在spring的提交事务中commit或者rollback后关闭，最终也会调用DataSourceUtils.releaseConnection(this.connection, this.dataSource);

SqlSessionFactoryBean的设计与实现
1）SqlSessionFactoryBean实现了InitializingBean接口，因此在实例化SqlSessionFactoryBean的时候会执行afterPropertiesSet
2）在afterPropertiesSet会给类字段sqlSessionFactory赋值，其最终会通过FactoryBean的getObject注入到applicationContext中
3）给SqlSessionFactory设置datasource、mapperLocations(xxxmapper.xml)、configLocation（mybatis-config.xml）、Interceptors等属性  
4）通过XMLConfigBuilder解析mybatis-config.xml生成configuration  
5）根据datasource生成transactionFactory，默认是使用的SpringManagedTransactionFactory事务管理器（其默认没有事务，因此经常在spring中看到@Transactional切面来配置事务）
6）通过XMLMapperBuilder来解析mapperLocation生产configuration的mapperRegistry对象（sql语句解析，MapperProxyFactory、mapperProxy动态代理对象等）。 
7）最后通过解析出来的configuration对象调用sqlSessionFactoryBuilder生成sqlSessionFactory对象。
8)最终通过getObject生成单列bean sqlSessionFactory(DefaultSqlSessionFactory)

Mapper的生成
1)调用ClassPathMapperScanner.doScan扫描配置basePackages.根据传的模式传找出该路径下的所有.class文件，将所有class转化为BeanDefinition. 然后将mapper接口的名字和beanDefinition加入到BeanDefinitionMap，为后续实例话mapper代理对象做准备（此时beanDefinition中的beanClass还是接口类）
2) 由于此时设置的BeanDefinition的beanClass是一个接口是不能通过getBean实例化，因此需要使用FactoryBean来处理，这里是通过将BeanDefinition的beanClass设置成mapperFactoryBean.class并添加mapperInterface参数为mapper接口，在MapperFactoryBean的getObject方法中会调用SqlSessionTemplate.getMapper(mapperInterface)来注册最终的mapperInterface的代理类。
3)通过之前的分析DefaultSqlSession不是线程安全的，而SqlSessionTemplate是单例、线程安全的sqlSession.  因此MapperFactoryBean中使用的是SqlSessionTemplate
4) SqlSessionTemplate是通过静态代理sqlSessionProxy来执行的，而sqlSessionProxy则通过动态SqlSessionInterceptor拦截所有的sqlSession的方法执行，在内部首先从threadLocal中获取sqlSession,如果没有获取到则通过sqlSessionFactory创建一个sqlSession对象，并保存在threadLocal中。在执行的时候如果该接口方法没有@Transation标注即没有事务会执行完成后sqlSession.commint(true)一下，会导致一级缓存被清空。因此只有在同一线程中并且具有同一事务的操作才会使用一级缓存。因为在Spring默认的DataSourceTransactionManager的getTransaction方法中（实际上调用的是unbindResource）对于新的事务会重置ThreadLocal保存的值，因此在第二次获取SqlSession的时候获取不到，就会新建一个sqlSession，因此不会使用一级缓存。
5) SqlSession的线程安全是通过SqlSessionTemplate的动态代理，每个线程的每一个事务生成一个ThreadLocal SqlSession，同时只有同一个事务的两次方法调用才能复用threadLocal 的SqlSession


mybatis和spring结合
在springboot源码中我们提到了一个非常重要的BeanDefinitionRegistryPostProcessor接口，其实现类ConfigurationClassPostProcessor用于扫描所有的注解@Configuration、@ComponentScan、@Import等注解然后将扫描到的class生成BeanDefinition后面被applicationContext refresh的时候实例化bean. 
所以其会调用ImportBeanDefinitionRegistrar的registerBeanDefinitions，而MapperScannerRegistrar就是一个ImportBeanDefinitionRegistrar。其最终会注入一个MapperScannerConfigurer。 而该MapperScannerConfigurer是负责根据mapper接口生成mapperName对应的BeanDefinition(是一个MapperFactoryBean类型的BeanDefinition).
mysql的SqlSessionFactory是通过配置spring.factories的EnableAutoConfiguration来生成的。因为@EnableAutoCOnfiguration会导入AutoConfigurationImportSelector，该类是一个DeferredImportSelector接口，改接口会被ConfigurationClassPostProcessor中处理从而将spring.factories的EnableAutoConfiguration生成BeanDefinition


解决事务方法里面调用this.method方法不带事务的问题
原因：因为事务方法是通过反射调用的因此传入的this对象是原始对象不是事务增强后的对象，因此在方法内嵌套调用的方法是不带事务的
方法：不同this去调用，通过拿到代理对象去调用

@Transactional(rollbackFor = Exception.class)
@Override
public OperationLog nestTransaction(Long id) {
    OperationLog operationLog=operationLogMapper.findById(id);
    return ((OperationLogService)AopContext.currentProxy()).findById(id);
}

@Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW)
@Override
public OperationLog findById(Long id) {
   return operationLogMapper.findById(id);
}
propagation = Propagation.REQUIRES_NEW 一级缓存不生效  propagation = Propagation.REQUIRED和propagation = Propagation.NESTED 则继承事务，一级缓存生效
注意要使用：AopContext需要在配置类上加上注解：@EnableAspectJAutoProxy(proxyTargetClass = true, exposeProxy = true) 使得增强对象会保存到ThreadLocal中。

